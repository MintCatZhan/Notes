1. 线程共享与独享：

   |  线程共享资源   | 线程独享资源 |
   | :-------: | :----: |
   |   地址空间    | 程序计数器  |
   |   全局变量    |  寄存器   |
   |    子进程    |   栈    |
   |   打开的文件   |  状态字   |
   |    闹钟     |        |
   | 信号和信号服务程序 |        |
   |   记账信息    |        |

   ​

2. OSI模型相关描述：

   |      |      数据单元      |    层    | 功能                                       |
   | :--: | :------------: | :-----: | ---------------------------------------- |
   | 主机层  |    Data(数据)    |  7.应用层  | 网络进程到应用程序。针对特定应用规定各层协议、时序、表示等，进行封装。在端系统中用软件来实现，如http等 |
   | 主机层  |    Data(数据)    |  6.表示层  | 数据表示形式，加密和解密，把机器相关的数据转换成独立于机器的数据。规定数据的格式化表示，数据格式的转换等 |
   | 主机层  |    Data(数据)    |  5.会话层  | 主机间通讯，管理应用程序之间的会话。规定通信时序；数据交换的定界、同步、创建检查点等 |
   | 主机层  | Segments(数据段)  |  4.传输层  | 在网络的各个节点之间可靠地分发数据包。所有传输遗留问题；复用；流量；可靠     |
   | 媒介层  |   网络分组/数据报文    |  3.网络层  | 在网络的各个节点之间进行地址分配、路由和不一定可靠的分发报文。路由（IP寻址）；拥塞控制 |
   | 媒介层  | Bit/Frame(数据帧) | 2.数据链路层 | 一个可靠的点对点数据直链。检错与纠错（CRC码）；多路访问；寻址         |
   | 媒介层  |    Bit(比特)     |  1.物理层  | 一个不一定可靠的点对点数据直链。定义机械特性；电气特性；功能特性；规程特性    |

3. 关于堆：

   - 堆分为最大堆和最小堆
   - 最大堆中所有父节点都比左子树、右子树大 

      ![Screen Shot 2017-09-02 at 10.08.27 pm](https://ws2.sinaimg.cn/large/006tKfTcgy1fj5h70qocaj30ha0c20t4.jpg)

   - 最小堆中所有父节点都比左子树、右子树小

      ![Screen Shot 2017-09-02 at 10.08.35 pm](https://ws3.sinaimg.cn/large/006tKfTcgy1fj5h72bxvrj30g40bojrr.jpg)

4. Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。

   - throw用于抛出异常。
   - throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。
   - try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。
   - cacth用于捕获从try中抛出的异常并作出处理。
   - finally语句块是不管有没有出现异常都要执行的内容。

5. 如果代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。线程安全问题都是由全局变量及静态变量引起的。

   - 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。
   - LinkedList 和 ArrayList 都是不同步的，线程不安全；
   - Vector 和 Stack 都是同步的，线程安全；
   - Set是线程不安全的；
   - Hashtable的方法是同步的，线程安全；
   - HashMap的方法不是同步的，线程不安全；

6. 用来实现序列化的类都在java.io包中，我们常用的类或者接口有：

   - ObjectOutputStream：提供序列化对象并且将其写入流的方法
   - ObjectInputStream：读取流并反序列化对象
   - Serializable：一个对象想要被序列化，那么它的类就要实现此接口，这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递
   - Externalizable：他是Serializable接口的子类，有时候不希望序列化那么多，就可以使用这个接口，这个接口的writeExternal()和readExternal()方法可以指定序列化有那些属性

7. 基本类型的数据可以直接序列化

8. 对象要被序列化，它的类必须实现Serializable接口，如果一个类中有引用类型的实例变量，这个引用类型也要实现Serializable接口。比如Student类中有一个Book类型的实例，想要让Student对象成功序列化，那么Book类型也需要实现Serializable接口，如果不想让Book实现，那么在Student类中，使用transient来修饰Book即可。

9. 两个问题：

   - 如果一个类没有实现Serializable接口，但是它的基类实现了，这个类是否可以序列化？
     - 可以，如果一个类实现了某个接口，那么它的所有子类都简介实现了这个接口，所以其子类可以被序列化
   - 如果一个类实现了Serializable接口，但是其父类没有实现，这个类是否可以序列化？
     - Object是每一个类的超类，但是它没有实现Serializable接口，但我们依然在序列化对象，所以说明一个类想要序列化，并不是一定要求其父类实现Serializable接口。如果父类没有实现Serializable接口，但是子类实现了，那么这个子类是可以序列化的，但是反序列化的过程中会调用父类的无参构造，所以其直接父类必须含有一个无参构造器

10. Java类成员的访问控制权限：public > protected > default > private

   |        | private | default | protected | public |
   | :----: | :-----: | :-----: | :-------: | :----: |
   |  同一类   |    Y    |    Y    |     Y     |   Y    |
   | 同一包中的类 |         |    Y    |     Y     |   Y    |
   |   子类   |         |         |     Y     |   Y    |
   | 其他包中的类 |         |         |           |   Y    |

11. `public Method[] getDeclaredMethods()`返回类或接口声明的所有方法，包括public, protected, default (package) 访问和private方法的Method对象，但不包括继承的方法。当然也包括它所实现接口的方法。`public Method[] getMethods()`返回类的所有public方法，包括其继承类的公用方法，当然也包括它所实现接口的方法。

12. 含有abstract修饰符的class即为抽象类，abstract类不能创建实例对象。

    含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。

    abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。

    接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

    下面比较一下两者的语法区别：

    - 抽象类可以有构造方法，接口中不能有构造方法。
    - 抽象类中可以有普通成员变量，接口中没有普通成员变量
    - 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
    - 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
    - 抽象类中可以包含静态方法，接口中不能包含静态方法
    - 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
