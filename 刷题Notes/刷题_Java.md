1. **装箱、拆箱**：基本数据类型和包装类之间的转换

   - 基本数据类型转化为包装类就是**装箱**
   - 包装类转化为基本数据类型就是**拆箱**
   - 包装类就是引用类型，基本类型就是值类型

2. Java并发中：

   - CopyOnWriteArrayList适用于**写少读多**的并发场景
   - ReadWriteLock为读写锁，要求<u>写与写之间互斥</u>、<u>读与写之间互斥</u>、<u>读与读之间可以并发执行</u>。在**读多写少的情况下可以提高效率**。
   - ConcurrentHashMap是同步的HashMap，读和写都加锁
   - Volatile只保证多线程操作的可见性，并不能保证其原子性

3. 下面那些情况可以终止当前线程的运行？

   - 当一个优先级高的线程进入就绪状态时
     - 实际上当一个优先级高的线程进入就绪状态的时候，它只是有较高的概率能够抢到CPU的执行权，并非一定可以抢到执行权
   - **抛出一个异常时**
     - 实际上，抛出异常后，线程就终止了
   - 当该线程调用sleep()方法时
     - 当线程调用sleep()或者wait()方法时，只是暂时停止了该线程的运行，并非终止线程。
   - 当创建一个新线程时
     - 创建一个新的线程时，该线程也加入到了抢占cpu执行权的队伍中，但是是否能够抢到并不确定
   - 实际上，能够结束线程的三个原因是：
     - run()方法执行完成，线程正常结束
     - 线程抛出一个未捕获的Exception或者Error
     - 直接调用该线程的Stop()方法结束线程——不建议使用，容易死锁

4. Java鲁棒性：

   - Java在编译和运行程序的时候，都要对可能出现的问题进行检查，以消除错误的产生
   - 它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误
   - 通过集成的面向对象的例外处理机制，在编译的时候，Java揭示可能出现但是未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃
   - Java在编译的时候可以捕获类型生命中的许多常见错误，防止动态运行时不匹配问题的出现。

5. Java标识符：由**<u>数字、字母、下划线、美元符号</u>**组成，其**首位不能是数字**，且**Java关键字不能作为标识符**

6. 关于Java异常处理：

   - throws用在方法上，声明该方法不需要处理的异常类型，其后跟着异常类名，可以是多个异常类
   - throw用在方法内，用于抛出具体异常类的对象，后面跟的异常对象只能是一个异常类型实体
   - try块必须和catch块或者finally同在，不可以单独存在，catch和finally必有其一
   - finally块总会执行，无论是否有错误出现，但是如果try语句块或者会执行的catch语句块中是用来JVM系统退出语句，那么finally块无法执行
   - 一般豆浆关闭资源的代码放在finally里，保证资源总是能够被正确关闭

7. Java中，构造函数不能够被继承，只能够被显式或者隐式地调用。

8. Java IO：

   ![Screen Shot 2017-09-08 at 8.30.15 pm](https://ws1.sinaimg.cn/large/006tNc79gy1fjcc29kw5pj30qu0to77h.jpg)

9. 在jdk1.5的环境下，有如下4条语句：

   ```java
   Integer i01 = 59;
   int i02 = 59;
   Integer i03 = Integer.valuOf(59);
   Integer i04 = new Integer(59);
   ```

   以下输出结果为false的是：

   ```java
   System.out.println(i01 == i02);
   System.out.println(i01 == i03);
   System.out.println(i03 == i04); // false
   System.out.println(i02 == i04); //i02为基本数据类型，比较的时候比较的是数值
   ```

   因为：JVM中，**一个字节以下的整型数据会在JVM启动的时候加载进入内存**，除非使用`new Integer()`来显式地创建对象，否则都是同一个对象。

10. Java对象的初始化方式有：**初始化块**、**构造器**、**定义变量时指定初始化值**