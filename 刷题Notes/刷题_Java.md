1. **装箱、拆箱**：基本数据类型和包装类之间的转换

   - 基本数据类型转化为包装类就是**装箱**
   - 包装类转化为基本数据类型就是**拆箱**
   - 包装类就是引用类型，基本类型就是值类型

2. Java并发中：

   - CopyOnWriteArrayList适用于**写少读多**的并发场景
   - ReadWriteLock为读写锁，要求<u>写与写之间互斥</u>、<u>读与写之间互斥</u>、<u>读与读之间可以并发执行</u>。在**读多写少的情况下可以提高效率**。
   - ConcurrentHashMap是同步的HashMap，读和写都加锁
   - Volatile只保证多线程操作的可见性，并不能保证其原子性

3. 下面那些情况可以终止当前线程的运行？

   - 当一个优先级高的线程进入就绪状态时
     - 实际上当一个优先级高的线程进入就绪状态的时候，它只是有较高的概率能够抢到CPU的执行权，并非一定可以抢到执行权
   - **抛出一个异常时**
     - 实际上，抛出异常后，线程就终止了
   - 当该线程调用sleep()方法时
     - 当线程调用sleep()或者wait()方法时，只是暂时停止了该线程的运行，并非终止线程。
   - 当创建一个新线程时
     - 创建一个新的线程时，该线程也加入到了抢占cpu执行权的队伍中，但是是否能够抢到并不确定
   - 实际上，能够结束线程的三个原因是：
     - run()方法执行完成，线程正常结束
     - 线程抛出一个未捕获的Exception或者Error
     - 直接调用该线程的Stop()方法结束线程——不建议使用，容易死锁

4. Java鲁棒性：

   - Java在编译和运行程序的时候，都要对可能出现的问题进行检查，以消除错误的产生
   - 它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误
   - 通过集成的面向对象的例外处理机制，在编译的时候，Java揭示可能出现但是未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃
   - Java在编译的时候可以捕获类型生命中的许多常见错误，防止动态运行时不匹配问题的出现。

5. Java标识符：由**<u>数字、字母、下划线、美元符号</u>**组成，其**首位不能是数字**，且**Java关键字不能作为标识符**

6. 关于Java异常处理：

   - throws用在方法上，声明该方法不需要处理的异常类型，其后跟着异常类名，可以是多个异常类
   - throw用在方法内，用于抛出具体异常类的对象，后面跟的异常对象只能是一个异常类型实体
   - try块必须和catch块或者finally同在，不可以单独存在，catch和finally必有其一
   - finally块总会执行，无论是否有错误出现，但是如果try语句块或者会执行的catch语句块中是用来JVM系统退出语句，那么finally块无法执行
   - 一般豆浆关闭资源的代码放在finally里，保证资源总是能够被正确关闭

7. Java中，构造函数不能够被继承，只能够被显式或者隐式地调用。

8. Java IO：

   ![Screen Shot 2017-09-08 at 8.30.15 pm](https://ws1.sinaimg.cn/large/006tNc79gy1fjcc29kw5pj30qu0to77h.jpg)

9. 在jdk1.5的环境下，有如下4条语句：

   ```java
   Integer i01 = 59;
   int i02 = 59;
   Integer i03 = Integer.valuOf(59);
   Integer i04 = new Integer(59);
   ```

   以下输出结果为false的是：

   ```java
   System.out.println(i01 == i02);
   System.out.println(i01 == i03);
   System.out.println(i03 == i04); // false
   System.out.println(i02 == i04); //i02为基本数据类型，比较的时候比较的是数值
   ```

   因为：JVM中，**一个字节以下的整型数据会在JVM启动的时候加载进入内存**，除非使用`new Integer()`来显式地创建对象，否则都是同一个对象。

10. Java对象的初始化方式有：**初始化块**、**构造器**、**定义变量时指定初始化值**

11. 执行如下程序，结果为： 

    ```java
    class Test{
      private int data;
      int result = 0;
      public void m() {
        result += 2;
        data += 2;
        System.out.print(result + " " + data);
      }
    }
    class ThreadExample extends Thread {
      private Test mv;
      public ThreadExample(Test mv) {
        this.mv = mv;
      }
      public void run() {
        synchronized(mv) {
          mv.m();
        }
      }
    }
    class ThreadTest {
      public static void main(String args[]) {
        Test mv = new Test();
        Thread t1 = new ThreadExample(mv);
        Thread t2 = new ThreadExample(mv);
        Thread t3 = new ThreadExample(mv);
        t1.start();
        t2.start();
        t3.start();
      }
    }
    // 2 24 46 6
    // 加了锁，所以三条线程以此计算即可
    ```

12. Java中的补码表示一个数，并非原码，第一位表示正负，1表示负，0表示正：

    {0}. 原码：一个数的二进制表示
       {0}. 3的原码是00000011，-3的原码是10000011
    {0}. 反码：负数原码按位取反，符号位不变，正数原码本身
       {0}. 3的反码是00000011，-3的反码是11111100
    {0}. 补码：正数是原码本身，负数反码加一
       {0}. 3的补码是00000011，-3的补码是11111101
    {0}. 在内存中表示：因为int占4个字节，32位；byte占一个字节，8位
       {0}. int a = 3: 00000000 00000000 00000000 00000011 （强制转型的时候，前24位0被截断）
       {0}. byte b = 3： 00000011
       {0}. int a = -3：11111111 11111111 11111111 11111101
       {0}. byte b = -3：11111101

13. byte + byte = int，**低级向高级是隐式类型转换，高级向低级必须强制类型转换**，byte < char < short < int < long < float < double

14. 以下代码的结果：

    ```java
    int i = 5;
    int j = 10;
    System.out.println(i + ~j);

    // 10的原码是: 00000000 00000000 00000000 00001010
    // ~10的结果是: 11111111 11111111 11111111 11110101 因为是负数，计算机用补码来存储
    // ~10的反码是: 10000000 00000000 00000000 00001010
    // ~10的补码是: 10000000 00000000 00000000 00001011 等于-11
    // 所以结果为-6
    ```

    **已知负数的补码，求负数：**

    **补码 - 1 = 反码，反码按位取反 = 该负数绝对值**

    **已知负数，求负数的补码：**

    **1、负数原码除了符号位，按位取反（不含符号位），加1。**

    **2、负数绝对值的补码（也就是原码），按位取反（含符号位），加1**

15. 关于Volatile：

    {0}. 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，就具备了两层语义:
       {0}. 保证了不同线程对这个变量操作时的可见性，即一个线程修改了某个变量的值，这个新的值对于其他线程来说是立即可见的
       {0}. 禁止进行指令重排序优化
    {0}. volatile只提供了保证访问该变量的时候，每次都是从内存中读取最新的值，并不会使用寄存器缓存该值（每次都从内存中读取）。而对于该变量的修改，volatile本身并不提供原子性的保证
    {0}. 由于有些时候对于volatile的操作，并不会被保存，说明不会造成阻塞
    {0}. 多线程下，计数器必须使用锁来保护

16. Java提供了一个系统级的线程，即垃圾回收器线程，用来对每一个分配出去的内存空间进行跟踪。当JVM空闲的时候，自动回收每一块可能被回收的内存，GC完全自动，不能被强制执行。程序员最多只能通过System.gc()来建议执行垃圾回收器来回收内存，但是具体的回收时间并不可知。当对象的引用变量被赋值为null的时候，可能会被当成垃圾。对于局部变量而言，其位于栈，而栈上的垃圾回收由finalize()来实现，而非GC，因为GC适用于堆。

17. 在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用super(参数或者无参数)来显式地指定调用父类构造器的时候，是默认调用父类的无参构造器，如果父类中含有带参构造器，却没有无参构造器，那么在子类构造器中一定要使用super(参数)来指定调用父类的带参构造器，负责会报错。

18. Servlet: 

    {0}. getParameter()获取POST/GET传递的参数值
    {0}. getInitParameter获取Tomcat的server.xml中设置Context的初始化参数
    {0}. getAttribute()是获取对象容器中的数据值
    {0}. getRequestDispatcher请求转发

19. ArrayList和LinkedList：

    {0}. **ArrayList是实现了基于动态数组的数据结构，LinkedLists是基于链表的数据结构**：这里的动态数组并非是“有多少元素就申请多少空间”，而是，如果没有指定数组的大小，则默认申请大小为10的数组，当元素的个数增加，数组无法存储的时候，系统就会另外再申请一个长度为当前长度1.5倍的数组，然后，将之前的数据拷贝到新建的数组
    {0}. **对于随机访问get和set，ArrayList觉得优先于LinkedList，因为Linkedlist需要移动指针**：ArrayList是数组，所以，直接定位到相应的位置来获取元素，而LinkedList是链表，需要从前往后遍历。
    {0}. **对于新增和删除操作，add和remove，LinkedList比较占优势，因为ArrayList需要移动数据**：ArrayList的新增和删除，就是数组的新增和删除，而LinkedList与链表一致
    {0}. **ArrayList的空间浪费主要体现在list列表的结尾需要预留一定的容量空间，而LinkedList的空间花费则体现在他们的每一个元素都需要消耗相当的空间**：因为ArrayList空间的增长率为1.5倍，那么，最后很可能会预留一部分空间没有被用到，继而造成浪费，对于LinkedList，犹豫每一个节点都需要额外的指针，所以导致空间的浪费。

20. Java中不允许单独的方法、过程或者函数存在，必须要隶属于某一类中； Java语言中的方法属于对象的成员，而不是类的成员，不过，其中静态方法属于类的成员。

21. 接口是对一类事物的属性和行为更高层次的抽象，对修改关闭，对拓展开放，接口是对开闭原则的一种体现，所以接口的属性用public static final修饰。

22. 关于JVM内存配置参数：

    ```
    -Xmx: 最大堆大小
    -Xms: 初始堆大小
    -Xmn: 年轻代大小
    -XXSurvivorRatio: 年轻代中Eden区与Survivor区的大小比值
    ```

23. ​