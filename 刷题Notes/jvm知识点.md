### JVM运行内存的分类

1. 程序计数器：当前线程所执行的字节码的指示器，用于记录下一条要运行的指令，线程私有
2. Java虚拟栈：存放基本数据类型和对象的引用，线程私有
3. Native方法栈：和虚拟栈相似，只不过它服务于Native方法，同样线程私有
4. Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，线程共享
5. 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。永久带，各线程共享

### Java内存堆和栈区别

1. 栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是**成员变量**，局部变量，还是类变量，它们指向的对象都存储在堆内存中
2. 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问
3. 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError
4. 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小

### GC回收机制

1. Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控
2. Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理
3. 可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用

### GC 标记对象的死活

1. 引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A->B,B->A,那么 AB 将永远不会被回收了。也就是引用有环的情况
2. 根搜索算法(可达性算法) GC Roots Tracing：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括:java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象

### GC 回收算法

1. 标记-清除法：标记出没有用的对象,然后一个一个回收掉。两个问题:效率和空间问题。产生很多的内存碎片,怡然不可以使用
2. 标记-整理法:将存活的对象向前移动,连续起来,然后将端以外的内存区域全部清空
3. 复制算法: 按照容量,划分二个大小相等的内存区域,当一块用完的时候将存活的对象复制过来

> ```
>  Serial New收集器是针对新生代的收集器，采用的是复制算法
>  Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理
>  Parallel  Scavenge（并行）收集器，针对新生代，采用复制收集算法
>  Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理
>  Parallel   Old（并行）收集器，针对老年代，标记整理
>  CMS收集器，基于标记清理
>  G1收集器(JDK)：整体上是基于标记清理，局部采用复制
> ```
>
> 综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理

### MinorGC&FullGC

> 新生代：初始对象，生命周期短的、 永久代(老年代)：长时间存在的对象

1. .Minor Gc通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生Gc的频率较高，回收速度比较快
2. Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度

### Java 堆内存的分配策略

1. Young区：又分为 Eden 区,survivior 1 和 survivior 2，Old 区
2. 一般小型的对象都会在 Eden 区上分配
3. 当内存不够时候发生 minor GC，将存活的对象拷贝到 survivor 1 区域，(此时 2 是空的),然后清空 Eden
4. 大对象直接进入老年代.
5. 长期存活的对象将直接进入老年代.

### Class 的加载过程

1. 加载过程:
2. 验证过程:
3. 准备过程:
4. 解析阶段:
5. 初始化阶段：

### 类加载器

1. 类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次
2. Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现
3. Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的
4. System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径

### 自定义ClassLoader

1. loadClass(String name,boolean resolve) 根据指定的二进制名称加载类          
2. findClass(String name) 根据二进制名称来查找类
3. 可以直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、 java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader
4. 在调用loadClass方法时，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载

### 双亲委派模型&打破双亲委派模型

1. 重写loaderClass方法打破双亲委派模型？
2. 为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载

### 引起类初始化操作的四个行为

1. 使用 new 关键字创建对象的时候,读取或者设置一个类的自动字段的时候(final 类得不会,因为在准备阶段因为复制)以及调用一个类的静态方法的时候     
2. 反射调用的时候         
3. 子类初始化的时候
4. 改类为主类的时候(有 main(string[] args))