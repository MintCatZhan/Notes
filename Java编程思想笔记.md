# 第八章 多态

1. 后期绑定：在运行时根据对象的类型进行绑定，绑定是指将一个方法调用同一个方法主体关联起来。
2. Java中除了static和final方法（private方法属于final方法）之外，其他所有方法都是后期绑定。所以将某一个方法设定为final，可以有效地关闭动态绑定，告诉编译器不需要对其进行动态绑定。但是大多数情况下，应该根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。
3. 多态是一种让程序员将改变的事物与未变的事物分离开来的技术。
4. 只有非private方法才可以被覆盖，但是仍然需要注意覆盖private方法的现象，好的处理办法是，在导出类中，对于基类中的private方法，最好使用不同的名字。
5. 只有普通的方法调用可以是多态的，如果是直接访问某个域，那么这个访问就在编译期进行解析。但是实际情况下，一般会把所有的域（field）设置为private，所以并不能直接访问它们，当然，副作用是只能通过调用方法来访问。此外，基类和导出类中的域一般有不同的名字。
6. 如果某一个方法是静态的，那么它的行为就不具有多态性。因为静态方法是与类，而非单个对象相关联的。
7. 基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每一个基类的构造器都能够得到调用。
8. 复杂对象调用构造器的顺序：
   - 调用基类构造器，这个步骤不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，直到最低层的导出类；
   - 按照声明顺序调用成员的初始化方法；
   - 调用导出类构造器的主体。
9. 销毁的顺序：
   - 对于基类，应该首先对其导出类进行清理，然后才是基类；
   - 导出类的清理可能会调用基类的某些方法，所以需要使基类中的构件仍起作用而不应该过早的销毁
10. 关于final：
    - final类不能被继承、没有子类，final类中的方法默认是final方法；
    - final方法不能被子类的方法覆盖，但是可以被继承；
    - final成员变量表示常量，只能被赋值一次，赋值之后值不可以被改变；
    - final不能用于修饰构造方法
    - 父类的private成员方法是不能被子类方法覆盖的，所以private方法默认是final类型的
11. 初始化的实际过程：
    - 在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零；
    - 如前所述那样调用基类构造器；
    - 按照声明的顺序调用成员的初始化方法；
    - 调用导出类的构造器主体
12. 编写构造器时：用尽可能简单的方法来使对象进入正常状态，如果可以的话，尽可能避免调用其他方法。构造器内唯一能够安全调用的方法是基类中的final方法（也适用于private方法，他们自动属于final方法）。这些方法不能被覆盖。
13. 总结：
    - 多态意味着不同的形式，在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法









# 第十三章 字符串

1. String对象是不可变的，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象丝毫未动。
2. 每当把String对象当做方法的参数时，都会复制一份引用，而该引用所指的对象一直待在单一的物理位置上，从未动过。
3. 简言之：当为一个类编写toString()方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理的构造最终的字符串结果，但是，如果需要在toString()方法中使用循环，那么最好自己创建一个StringBuilder对象，用来构造最终的结果。
4. StringBuilder提供丰富而全面的方法：insert(), replace(), substring(), reverse(), delete(), append() & toString().
5. 如果想打印出对象的内存地址，应该调用Object.toString()方法，所以不应该是用this，而是调用super.toString()方法。
6. 当需要改变字符串的内容时，String类的方法都会返回一个新的String对象，同时，如果内容没有发生改变，String的方法只是返回指向原对象的引用，这样可以节约存储空间以及避免额外开销。
7. 正则表达式深坑。。。





# 第十六章 数组

1. 数组与其他种类的容器之间的区别在于：效率、类型和保存基本类型的能力。
2. 数组是一种效率最高的存储和随机访问对象引用序列的方式，它是一个简单的线性序列，使得匀速访问非常快速，代价是数组对象的大小被固定，且在其生命周期中不可改变。
3. 在泛型之前，其他的容器在处理对象时，都将它们视作没有任何具体类型，也就是说，它们将这些对象都当做Java中所有类的根类Object处理。数组之所以优于泛型之前的容器，就是因为可以创建一个数组去持有某种具体类型。
4. 对象数组和基本类型数组在使用上几乎是相同的，唯一区别在于，对象数组保存的是引用，基本类型数组直接保存基本类型的值。
5. 如果一个数组是尚未初始化的局部变量，在对其进行正确地初始化之前，编译器不允许用此引用做任何事情。
6. 如果一个数组指向一个存有引用的数组，但是并没有此引用的对象置于数组中，仍然可以询问数组的大小，因为该数组指向一个合法的对象。不过，无法知道该数组中确切有多少元素，因为length只能表示数组能够容纳多少元素，即length只是数组的大小，而非实际保存的元素个数。
7. java.util.Arrays类的static实用方法：
   - equals()用于比较两个数组是否相等（deepEquals()用于多维数组）
   - fill()用单一值填充数组
   - sort()用于对数组排序
   - binarySearch()用于在已经排序过的数组中查找元素
   - toString()产生数组的String表示
   - hashCode()产生数组的散列码
8. System.arraycopy()用于复制数组，较for循环快很多。
   - System.arraycopy(源数组，从源数组什么位置开始复制的偏移量，目标数组，从目标数组什么位置开始粘贴的偏移量，需要复制的元素个数);
   - 基本类型数组和对象数组都可以复制，然而，如果复制对象数组，那么只是复制了对象的引用，而非对象本身的拷贝，这被称作浅复制（shallow copy）。
9. equals()方法，数组相等的条件是元素个数相等，并且对应位置的元素也相等（**基于内容，而非引用**）。