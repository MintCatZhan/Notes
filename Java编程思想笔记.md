# 第五章 初始化和清理

1. 创建对象的时候，如果其类具有构造器，Java会在用户有能力操作对象之前自动调用相对应的构造器，从而保证初始化的进行。在创建对象的时候，将会为对象分配存储空间，并且调用相对应的构造器。

   - 不接受任何参数的构造器叫做<u>默认构造器</u>，或者叫做<u>无参构造器</u>
   - 理论上，“初始化”和“创建”是彼此独立的。

2. 方法重载：如果已经有了一个默认构造器，想要有另一个方法名相同而形式参数不同的构造器同时存在，就需要方法重载。

   - 如果能保证每一个重载的方法都有一个独一无二的参数类型列表，即可保证Java明白所指定的方法是哪一个
   - 参数类型的差异、参数的顺序
   - 用返回来来区分重载方法行不通：因为有时候调用一个方法，并不在意该方法的返回值，而是想要方法调用的其他效果（为了副作用而调用），那么就可能只调用该方法而不明确去取得其返回值，这种情况下不能让Java理解是调用了哪一个方法

3. 如果所写的类中没有构造器，那么编译器会自动帮助完成一个默认构造器的创建，但是，如果已经定义了一个构造器（无论是否有参数），编译器都不会再帮你创建一个无参构造器。

4. this:

   - this关键字只能在方法内部使用，表示对“调用这个方法的对象”的引用
   - 在方法内部调用同一个类的另一个方法，其实就不需要使用this，直接调用即可
   - 只有在需要明确指出当前对象的引用时，才需要使用this关键字
   - 也可以在构造器中调用this，来调用另一个构造器

5. static:

   - static方法，就是没有this的方法
   - 在static方法的内部，不能够调用非静态的方法，反之却是可以的
   - 可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法，这是主要用途
   - 如果在Java的类中添加static方法，就可以调用其他的static方法和static域

6. 垃圾回收：

   - 使用垃圾回收器的唯一原因是为了回收程序不再使用的内存
   - 引用计数：
     - 简单，但是速度很慢的垃圾回收技术
     - 每个对象都含有一个引用计数器，当有引用连接到对象的时候，引用计数+1，当引用离开作用域或者被设置为null的时候，引用计数-1。
     - 垃圾回收期会在含有全部对象的列表上进行遍历，当发现某一个对象的引用计数为0的时候，将释放其占用的空间（引用计数模式经常会在计数值编程0的时候立刻释放对象）
     - 缺陷：如果对象之间存在有循环引用，那么会出现一个“对象应该被回收，但是引用计数却不为0”的几段情况
     - 实际上，引用计数常用来说明垃圾收集的工作方式，但是并没有被真的应用于任何一种java虚拟机实现
   - 停止-复制（stop-and-copy）：
     - 先暂停程序的运行（所以这种垃圾回收方式并不属于后台回收模式）
     - 将所有存货的对象从当前的堆复制到另一个堆，没有复制的全部都是垃圾
     - 当对象呗复制到新的堆时，其内存上的分布是一个个连续的，所以保证在新堆上的紧凑排列
     - 继而可以直接继续分配新的空间
     - 缺陷：效率会降低，首先需要两个堆；其次，因为程序进入稳定状态之后，可能只会产生少量垃圾，尽管如此，复制式的回收器仍然会将所有内存从一处复制到另一处，继而引入了标记-清扫（mark-and-sweep）的方式
   - 标记-清扫（mark-and-sweep）：
     - 从堆栈和静态存储区出发，遍历所有的引用，找到所有存活的对象
     - 每当找到一个存活对象，就会给对象设置一个标记，这个过程中不涉及任何对象的回收，只有完成了所有的标记动作后，才会开始清理动作
     - 清理过程中，没有标记的对象被清理，不会发生复制动作，完成清理后，剩下的堆空间是不连续的，需要重新整理剩下的对象来保证堆的连续性

7. 如果类的数据成员（即字段）是基本类型，会保证累的每个基本类型数据成员都会有一个初始值，而在类里定一个对象引用的时候，如果不将其初始化，这个引用就会获得一个特殊值null。

8. 初始化的顺序：

   - 在类的内部，变量定义的先后顺序决定了初始化的顺序，即是变量定义散布于方法定义之间，它们也会在任何方法调用前（包括构造器）得到初始化
   - 静态对象初始化会在必要的时刻下进行，比如说，如果不引用到这个静态对象，它将不被创建。初始化后，静态对象不会被再次初始化
   - 初始化的顺序是先**静态对象**（如果它们尚未因为前面的对象创建过程而被初始化），继而是**非静态对象**
   - 实例：
     - 有一个名作Dog的类：
     - 即使没有显式地使用static关键字，构造器实际上也是静态方法：因此，当首次创建类型为Dog的对象时，或者Dog类的静态方法/静态域首次被访问时，Java解释器需要查找类路径，以定位Dog.class文件
     - 载入Dog.class，有关静态初始化的所有动作都会被执行，因此静态初始化只在Class对象首次加载的时候进行一次
     - 当用new Dog()的时候，先在**堆**上为Dog对象分配足够的存储空间
     - 这块存储空间被清零，这就自动将Dog对象的所有基本类型数据设置为默认值（数字为0，布尔值和字符型也相同），而引用类型被设置成null
     - 执行所有出现于**字段定义处**的初始化动作
     - 执行构造器

9. 数组的初始化：数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或者基本类型数据序列。

10. 枚举类型

   - 创建一个名字为Spiciness的枚举类型，其具有5个具名值，犹豫枚举类型的实例都是常量，故按着习惯都用大写字母表示


    - ```java
      public enum Spiciness {
        NOT, MILD, MEDIUM, HOT, FLAMING
      }
      ```
    
    - 使用enum
    
    - ```java
      public class SImpleEnumUse {
        public staic void main(String[] args) {
          Spiciness howHot = Spiciness.MEDIUM;
          System.out.println(howHot);
        }
      }
      ```













# 第八章 多态

1. **封装**通过合并特征和行为来创建新的数据类型，**实现隐藏**则通过将细节私有化来把接口和实现分离开来。而多态的作用则是**消除类型之间的耦合关系**。
2. 把**<u>一个方法调用</u>**和**<u>一个方法主体</u>**关联起来叫做**绑定**。
3. 多态也叫做动态绑定、运行时绑定或者后期绑定：在**运行时**根据对象的类型进行绑定。编译器一直不知道对象的类型，但是方法调用机制能够找到正确的方法体并且加以调用。
4. Java中除了static和final方法（private方法属于final方法）之外，其他所有方法都是后期绑定。所以将某一个方法设定为final，可以有效地关闭动态绑定，告诉编译器不需要对其进行动态绑定。但是大多数情况下，应该根据设计来决定是否使用final，而不是出于试图提高性能的目的来使用final。
5. 多态是一种让程序员将改变的事物与未变的事物分离开来的技术。
6. 基类中的private方法，被自动认为是final方法，对导出类是屏蔽的，所以，子类中哪怕定义了一个和父类中这个private方法同名的方法，其**并非是对原有方法的重载**，因为**父类中的private方法对于子类不可见**。
7. 只有**非private方法才可以被覆盖**，但是仍然需要注意覆盖private方法的现象，好的处理办法是，在导出类中，对于基类中的private方法，最好使用不同的名字。
8. 只有普通的方法调用可以是多态的，如果是直接访问某个域，那么这个访问就在编译期进行解析。但是实际情况下，一般会把所有的域（field）设置为private，所以并不能直接访问它们，当然，副作用是只能通过调用方法来访问。此外，基类和导出类中的域一般有不同的名字。
9. 如果某一个方法是静态的，那么它的行为就不具有多态性。因为静态方法是与类，而非单个对象相关联的。
10. 基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使每一个基类的构造器都能够得到调用。
11. 复杂对象调用构造器的顺序：
    - 调用基类构造器，这个步骤不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，直到最低层的导出类；
    - 按照声明顺序调用成员的初始化方法；
    - 调用导出类构造器的主体。
    - 构造器的调用顺序很重：在进行继承的时候，我们已经知道了基类的一切，并可以访问基类中任何声明为pubic和protected的成员，这意味着，在导出类中，必须嘉定基类的所有成员都是有效的。
12. 销毁的顺序：
    - 对于基类，应该首先对其导出类进行清理，然后才是基类；
    - 导出类的清理可能会调用基类的某些方法，所以需要使基类中的构件仍起作用而不应该过早的销毁
13. 关于final：
    - final类不能被继承、没有子类，final类中的方法默认是final方法；
    - final方法不能被子类的方法覆盖，但是可以被继承；
    - final成员变量表示常量，只能被赋值一次，赋值之后值不可以被改变；
    - final不能用于修饰构造方法
    - 父类的private成员方法是不能被子类方法覆盖的，所以private方法默认是final类型的
14. 初始化的实际过程：
    - 在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零；
    - 如前所述那样调用基类构造器；
    - 按照声明的顺序调用成员的初始化方法；
    - 调用导出类的构造器主体
15. 编写构造器时：用尽可能简单的方法来使对象进入正常状态，如果可以的话，尽可能避免调用其他方法。构造器内唯一能够安全调用的方法是基类中的final方法（也适用于private方法，他们自动属于final方法）。这些方法不能被覆盖。
16. 总结：
    - 多态意味着不同的形式，在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法









# 第十三章 字符串

1. String对象是不可变的，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容，而最初的String对象丝毫未动。
2. 每当把String对象当做方法的参数时，都会复制一份引用，而该引用所指的对象一直待在单一的物理位置上，从未动过。
3. 简言之：当为一个类编写toString()方法时，如果字符串操作比较简单，那就可以信赖编译器，它会为你合理的构造最终的字符串结果，但是，如果需要在toString()方法中使用循环，那么最好自己创建一个StringBuilder对象，用来构造最终的结果。
4. StringBuilder提供丰富而全面的方法：insert(), replace(), substring(), reverse(), delete(), append() & toString().
5. 如果想打印出对象的内存地址，应该调用Object.toString()方法，所以不应该是用this，而是调用super.toString()方法。
6. 当需要改变字符串的内容时，String类的方法都会返回一个新的String对象，同时，如果内容没有发生改变，String的方法只是返回指向原对象的引用，这样可以节约存储空间以及避免额外开销。
















###### 


# 第十六章 数组

1. 数组与其他种类的容器之间的区别在于：效率、类型和保存基本类型的能力。
2. 数组是一种效率最高的存储和随机访问对象引用序列的方式，它是一个简单的线性序列，使得匀速访问非常快速，代价是数组对象的大小被固定，且在其生命周期中不可改变。
3. 在泛型之前，其他的容器在处理对象时，都将它们视作没有任何具体类型，也就是说，它们将这些对象都当做Java中所有类的根类Object处理。数组之所以优于泛型之前的容器，就是因为可以创建一个数组去持有某种具体类型。
4. 对象数组和基本类型数组在使用上几乎是相同的，唯一区别在于，对象数组保存的是引用，基本类型数组直接保存基本类型的值。
5. 如果一个数组是尚未初始化的局部变量，在对其进行正确地初始化之前，编译器不允许用此引用做任何事情。
6. 如果一个数组指向一个存有引用的数组，但是并没有此引用的对象置于数组中，仍然可以询问数组的大小，因为该数组指向一个合法的对象。不过，无法知道该数组中确切有多少元素，因为length只能表示数组能够容纳多少元素，即length只是数组的大小，而非实际保存的元素个数。
7. java.util.Arrays类的static实用方法：
   - equals()用于比较两个数组是否相等（deepEquals()用于多维数组）
   - fill()用单一值填充数组
   - sort()用于对数组排序
   - binarySearch()用于在已经排序过的数组中查找元素
   - toString()产生数组的String表示
   - hashCode()产生数组的散列码
8. System.arraycopy()用于复制数组，较for循环快很多。
   - System.arraycopy(源数组，从源数组什么位置开始复制的偏移量，目标数组，从目标数组什么位置开始粘贴的偏移量，需要复制的元素个数);
   - 基本类型数组和对象数组都可以复制，然而，如果复制对象数组，那么只是复制了对象的引用，而非对象本身的拷贝，这被称作浅复制（shallow copy）。
9. equals()方法，数组相等的条件是元素个数相等，并且对应位置的元素也相等（**基于内容，而非引用**）。