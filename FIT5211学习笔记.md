# Week 1

1. **Computer science**: the study of problems, problem-solving, and the solutions that come out of the problem-solving process. 
2. **Algorithm**: a step-by-step list of instructions for solving any instance of the problem that might arise. Algorithms are solutions.
3. **Computable**: a problem is computable if an algorithm exists for solving it.
4. **Abstraction** allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives.
5. **Programming** is the process of taking an algorithm and encoding it into a notation, a programming language, so that it can be executed by a computer. 
6. **Data types** provide an interpretation for this binary data so that we can think about the data in terms that make sense with respect to the problem being solved. 
7. An **abstract data type**, sometimes abbreviated **ADT**, is a <u>logical description</u> of <u>how we view the data and the operations that are allowed without regard to how they will be implemented</u>. 
8. The implementation of an abstract data type, often referred to as a **data structure**, will require that we provide a physical view of the data using some collection of programming constructs and primitive data types.
   - int char float double 这些是 数据类型 ，类比作原子，他们间的不同就是元素种类的不同，只涉及自身的不同，比如两种原子内的质子中子数不同，是一种内在属性。
   - 链表 队列 堆栈 树 这些是数据结构，类比作分子，他们间描述的是数据间的关系，就如同分子描述了原子的组合方式。
9. This is a **dynamic** **characteristic** of Python. The same variable can refer to many different types of data.
10. **Lists**, **strings**, and **tuples** are ordered collections that are very similar in general structure but have specific differences that must be understood for them to be used properly. **Sets** and **dictionaries** are unordered collections.
11. **Lists are mutable; strings are immutable**. For example, you can change an item in a list by using indexing and assignment. With a string that change is not allowed.
12. **Tuples** are very similar to lists in that they are **heterogeneous sequences of data**. The difference is that **<u>a tuple is immutable, like a string</u>**. A tuple cannot be changed. Tuples are written as comma-delimited values enclosed in parentheses. As sequences, they can use any operation described above.












# Week 2

1. **Stacks**, **queues**, **deques**, and **lists** (栈、队列、双队列、列表) are examples of data collections whose items are ordered depending on how they are added or removed. <u>Once an item is added, it stays in that position relative to the other elements that came before and came after it.</u> Collections such as these are often referred to as **linear data structures**.

2. A **stack** (sometimes called a “push-down stack”) is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. (填加和删除元素，都是发生在同一个终端，这一个终端被称为top，另一端称作base)

3. This ordering principle is sometimes called **LIFO**, **last-in first-out**. It provides an ordering based on length of time in the collection. Newer items are near the top, while older items are near the base.![Screen Shot 2017-07-31 at 10.26.27 am](https://ws4.sinaimg.cn/large/006tKfTcgy1fi2rff4lpej30nq0c4t95.jpg)

   - 栈的一个应用就是：网页的导航，每次跳转到一个新的页面，这期间的路径被保留在是一个栈中，所以在点击后退按钮的时候，就可以从栈中移除第一个页面，跳转回之前的页面

   - `Stack()` creates a new stack that is empty. It needs no parameters and returns an empty stack.

   - `push(item)` adds a new item to the top of the stack. It needs the item and returns nothing.

   - `pop()` removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.

   - `peek()` returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.

   - `isEmpty()` tests to see whether the stack is empty. It needs no parameters and returns a boolean value.

   - `size()` returns the number of items on the stack. It needs no parameters and returns an integer.

     ```python
     Class Stack:
      def __init__(self):
          self.items = []

      def isEmpty(self):
          return self.items == []

      def push(self, item):
          self.items.append(item)

      def pop(self):
          return self.items.pop()

      def peek(self):
          return self.items[len(self.items)-1]

      def size(self):
          return len(self.items)
     ```

4. **Balanced parentheses**means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. 

5. Check if parentheses are balanced:

   ```python
   def parChecker(symbolString):
   s = Stack()
   balanced = True
   index = 0
   while index < len(symbolString) and balanced:
       symbol = symbolString[index]
       if symbol == "(":
           s.push(symbol)
       else:
           if s.isEmpty():
               balanced = False
           else:
               s.pop()

       index = index + 1

   if balanced and s.isEmpty():
       return True
   else:
       return False
       
   print(parChecker('()))'))
   print(parChecker(')'))
   ```

6. **Recursion** is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself. While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program. 递归，将复杂的问题分解成简单的小问题，最后调用其自身，从而构建优雅的解决办法以解决问题。

   - 递归求和

     ```python
     def listsum(numList):
     	if len(numList) == 1:
     		return numList[0]
     	else:
     		return numList[0] + listsum(numList[1:])
         	print(listsum([1,3,5,7,9]))
     ```

   - 递归规则：

     - A recursive algorithm must have a **base case**.
     - A recursive algorithm must change its state and move toward the base case.
     - A recursive algorithm must call itself, recursively.













