# Week 1

1. **Computer science**: the study of problems, problem-solving, and the solutions that come out of the problem-solving process. 
2. **Algorithm**: a step-by-step list of instructions for solving any instance of the problem that might arise. Algorithms are solutions.
3. **Computable**: a problem is computable if an algorithm exists for solving it.
4. **Abstraction** allows us to view the problem and solution in such a way as to separate the so-called logical and physical perspectives.
5. **Programming** is the process of taking an algorithm and encoding it into a notation, a programming language, so that it can be executed by a computer. 
6. **Data types** provide an interpretation for this binary data so that we can think about the data in terms that make sense with respect to the problem being solved. 
7. An **abstract data type**, sometimes abbreviated **ADT**, is a <u>logical description</u> of <u>how we view the data and the operations that are allowed without regard to how they will be implemented</u>. 
8. The implementation of an abstract data type, often referred to as a **data structure**, will require that we provide a physical view of the data using some collection of programming constructs and primitive data types.
   - int char float double 这些是 数据类型 ，类比作原子，他们间的不同就是元素种类的不同，只涉及自身的不同，比如两种原子内的质子中子数不同，是一种内在属性。
   - 链表 队列 堆栈 树 这些是数据结构，类比作分子，他们间描述的是数据间的关系，就如同分子描述了原子的组合方式。
9. This is a **dynamic** **characteristic** of Python. The same variable can refer to many different types of data.
10. **Lists**, **strings**, and **tuples** are ordered collections that are very similar in general structure but have specific differences that must be understood for them to be used properly. **Sets** and **dictionaries** are unordered collections.
11. **Lists are mutable; strings are immutable**. For example, you can change an item in a list by using indexing and assignment. With a string that change is not allowed.
12. **Tuples** are very similar to lists in that they are **heterogeneous sequences of data**. The difference is that **<u>a tuple is immutable, like a string</u>**. A tuple cannot be changed. Tuples are written as comma-delimited values enclosed in parentheses. As sequences, they can use any operation described above.












# Week 2

1. **Stacks**, **queues**, **deques**, and **lists** (栈、队列、双队列、列表) are examples of data collections whose items are ordered depending on how they are added or removed. <u>Once an item is added, it stays in that position relative to the other elements that came before and came after it.</u> Collections such as these are often referred to as **linear data structures**.

2. A **stack** (sometimes called a “push-down stack”) is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. (填加和删除元素，都是发生在同一个终端，这一个终端被称为top，另一端称作base)

3. This ordering principle is sometimes called **LIFO**, **last-in first-out**. It provides an ordering based on length of time in the collection. Newer items are near the top, while older items are near the base.![Screen Shot 2017-07-31 at 10.26.27 am](https://ws4.sinaimg.cn/large/006tKfTcgy1fi2rff4lpej30nq0c4t95.jpg)

   - 栈的一个应用就是：网页的导航，每次跳转到一个新的页面，这期间的路径被保留在是一个栈中，所以在点击后退按钮的时候，就可以从栈中移除第一个页面，跳转回之前的页面

   - `Stack()` creates a new stack that is empty. It needs no parameters and returns an empty stack.

   - `push(item)` adds a new item to the top of the stack. It needs the item and returns nothing.

   - `pop()` removes the top item from the stack. It needs no parameters and returns the item. The stack is modified.

   - `peek()` returns the top item from the stack but does not remove it. It needs no parameters. The stack is not modified.

   - `isEmpty()` tests to see whether the stack is empty. It needs no parameters and returns a boolean value.

   - `size()` returns the number of items on the stack. It needs no parameters and returns an integer.

     ```python
     Class Stack:
      def __init__(self):
          self.items = []

      def isEmpty(self):
          return self.items == []

      def push(self, item):
          self.items.append(item)

      def pop(self):
          return self.items.pop()

      def peek(self):
          return self.items[len(self.items)-1]

      def size(self):
          return len(self.items)
     ```

4. **Balanced parentheses**means that each opening symbol has a corresponding closing symbol and the pairs of parentheses are properly nested. 

5. Check if parentheses are balanced:

   ```python
   def parChecker(symbolString):
   s = Stack()
   balanced = True
   index = 0
   while index < len(symbolString) and balanced:
       symbol = symbolString[index]
       if symbol == "(":
           s.push(symbol)
       else:
           if s.isEmpty():
               balanced = False
           else:
               s.pop()

       index = index + 1

   if balanced and s.isEmpty():
       return True
   else:
       return False
       
   print(parChecker('()))'))
   print(parChecker(')'))
   ```

6. Balanced Symbols—general case:

   ```python
   def parChecker(symbolString):
   	s = Stack()
   	balanced = True
   	index = 0
       while index < len(symbolString) and balanced:
           symbol = symbolString[index]
           if symbol in "([{":
               s.push(symbol)
           else:
               if s.isEmpty():
                   balanced = False
               else:
                   top = s.pop()
                   if not matches(top,symbol):
                          balanced = False
           index = index + 1
       if balanced and s.isEmpty():
           return True
       else:
           return False
       
   def matches(open,close):
   	opens = "([{"
   	closers = ")]}"
   	return opens.index(open) == closers.index(close)

   print(parChecker('{{()}()}'))
   print(parChecker('[{()]'))
   ```

7. **Recursion** is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get to a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself. While it may not seem like much on the surface, recursion allows us to write elegant solutions to problems that may otherwise be very difficult to program. 递归，将复杂的问题分解成简单的小问题，最后调用其自身，从而构建优雅的解决办法以解决问题。

   - 递归求和

     ```python
     def listsum(numList):
     	if len(numList) == 1:
     		return numList[0]
     	else:
     		return numList[0] + listsum(numList[1:])
         	print(listsum([1,3,5,7,9]))
     ```

   - 递归规则：

     - A recursive algorithm must have a **base case**.
     - A recursive algorithm must change its state and move toward the base case.
     - A recursive algorithm must call itself, recursively.

8. In Python square brackets, `[` and `]`, are used for lists; curly braces, `{` and `}`, are used for dictionaries; and parentheses, `(` and `)`, are used for tuples and arithmetic expressions. 

9. A queue is an ordered collection of items where the addition of new items happens at one end, called the “rear,” and the removal of existing items occurs at the other end, commonly called the “front.” As an element enters the queue it starts at the rear and makes its way toward the front, waiting until that time when it is the next element to be removed. **队列**，又稱為伫列（queue），是先进先出（**FIFO**, First-In-First-Out）的线性表。 在具体应用中通常用链表或者数组来实现。 **队列**只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。

   {0}.  `Queue()` creates a new queue that is empty. It needs no parameters and returns an empty queue.

   {0}.  `enqueue(item)` adds a new item to the rear of the queue. It needs the item and returns nothing.

   {0}.  `dequeue()` removes the front item from the queue. It needs no parameters and returns the item. The queue is modified.

   {0}.  `isEmpty()` tests to see whether the queue is empty. It needs no parameters and returns a boolean value.

   {0}.  `size()` returns the number of items in the queue. It needs no parameters and returns an integer.

   {0}.   Listing 1

      ```python
      class Queue:   
         def __init__(self):
             self.items = []

         def isEmpty(self):
             return self.items == []

         def enqueue(self, item):
             self.items.insert(0,item) // O(n)

         def dequeue(self):
             return self.items.pop() // O(1)

         def size(self):
             return len(self.items)
      ```

   {0}.  Hot Potato Simulation:

   {0}.  ```python
      def hotPotato(namelist, num):
             simqueue = Queue()
             for name in namelist:
                 simqueue.enqueue(name)

             while simqueue.size() > 1:
                 for i in range(num):
                     simqueue.enqueue(simqueue.dequeue())
                 simqueue.dequeue()
             return simqueue.dequeue()
      print(hotPotato(["Bill","David","Susan","Jane","Kent","Brad"],7))
      ```

10. A **list** is a collection of items where each item holds a relative position with respect to the others. More specifically, we will refer to this type of list as an unordered list. We can consider the list as having a first item, a second item, a third item, and so on. We can also refer to the beginning of the list (the first item) or the end of the list (the last item). For simplicity we will assume that lists cannot contain duplicate items.

  {0}.  `List()` creates a new list that is empty. It needs no parameters and returns an empty list.
  {0}.  `add(item)` adds a new item to the list. It needs the item and returns nothing. Assume the item is not already in the list.
  {0}.  `remove(item)` removes the item from the list. It needs the item and modifies the list. Assume the item is present in the list.
  {0}.  `search(item)` searches for the item in the list. It needs the item and returns a boolean value.
  {0}. `isEmpty()` tests to see whether the list is empty. It needs no parameters and returns a boolean value.
  {0}. `size()` returns the number of items in the list. It needs no parameters and returns an integer.
  {0}.  `append(item)` adds a new item to the end of the list making it the last item in the collection. It needs the item and returns nothing. Assume the item is not already in the list.
  {0}. `index(item)` returns the position of item in the list. It needs the item and returns the index. Assume the item is in the list.
  {0}. `insert(pos,item)` adds a new item to the list at position pos. It needs the item and returns nothing. Assume the item is not already in the list and there are enough existing items to have position pos.
  {0}. `pop()` removes and returns the last item in the list. It needs nothing and returns an item. Assume the list has at least one item.
  {0}. `pop(pos)` removes and returns the item at position pos. It needs the position and returns the item. Assume the item is in the list.

11. Linked List:

    ![Screen Shot 2017-08-01 at 12.54.28 pm](https://ws1.sinaimg.cn/large/006tNc79gy1fi41if0dy1j317i0lcwge.jpg)
    在一个linked list中添加一个新的node，其value为10，其指针或者说reference指向该链表的root node。添加完成后，该新node变成新的root node。![Screen Shot 2017-08-01 at 12.55.23 pm](https://ws3.sinaimg.cn/large/006tNc79gy1fi41iizt94j317k0lcabo.jpg)
    在尝试从linked list中删除一个元素的时候，我们先遍历链表，根据value找到对应的node，然后将这个node的前一个node的引用，指向这个node的后一个node。实际上，这个找到的node仍然存在，但是被排除在了现存的链表外。![Screen Shot 2017-08-01 at 12.58.56 pm](https://ws3.sinaimg.cn/large/006tNc79gy1fi41igzfsoj31780l4q4l.jpg)

12. Python code:

    ```python
    # python 定义node类，包含两个属性，data & nodeReference
    class Node(object):
    	def __init__ (self, d, n = None):
           self.data = d
           self.next_node = n
           
       def get_next (self):
           return self.next_node
       
       def set_next (self, n):
           self.next_node = n
           
       def get_data (self):
           return self.data
       
       def set_data (self, d):
           self.data = d
    ```

    ```python
    # 定义链表
    class LinkedList(object):
       def __init__ (self, r = None):
           self.root = r
           self.size = 0
       
       def get_size (self)：
       		return self.size
       
       def add (self, d):
           new_node = Node (d, self.root)
           self.root = new_node
           self.size += 1

       def remove (self, d):
           this_node = self.root
           prev_node = None
           
           while this_node:
               if this_node.get_data() == d:
                   # 如果该node的值等于所需要找的值
                   if prev_node:
                       # 如果找到的node有prev_node，
                       # 将前一个node的引用指向该node的下一个node
                       prev_node.set_next(this_node.get_next())
                   else:
                       # 否则，将该node设置为root_node
                       self.root = this_node
                   self.size -= 1
                   return True # 找到了这个node，成功移除
               else:
                   # 如果该node的值不等于所需的，将下一个node设置为this_node，将
                   # this_node设置为prev_node
                   prev_node = this_node
                   this_node = this_node.get_next()
           return False # 没有找到这个node，移除失败
       
       def find (self, d):
           this_node = self.root
           while this_node:
               if this_node.get_data() == d:
                   return d
               else:
                   this_node = this_node.get_next()
           return None
       
       myList = LinkedList()
       mylist.add(5)
       mylist.add(8)
       mylist.add(5)
       mylist.add(12)
       print(mylist.add(12))
       print(mylist.find(5))
    ```

    ​


