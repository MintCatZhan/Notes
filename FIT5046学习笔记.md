# Introduction To Mobile And Distributed Computing

1. **Distributed Computing**: a computing paradigm where <u>a number of autonomous machines</u> which are <u>geographically distributed/separated</u> can <u>communicate and exchange/transfer data through a computer network</u> to <u>perform certain related tasks</u>.

   1. Distribution of machines physically
   2. Distribution of data, processing, conrol, business logic/rules,...

2. **Computing Models**: Parallel processing, Virtualization, Utility computing, Computer clusters, grid computing, cloud computing, fogging, web services.

3. **Layers of a distributed system**: 

   1. applications & services
   2. middleware
   3. *distributed OS*(platform)
   4. *computer and network hardware* (platform)

4. **Architectural styles of distributed systems**:

   1. *Layered architecture*

      1. Grouping related functionalities into layers vertically
      2. Separation of concerns, flexibility, easy to maintain

   2. *Object-based architecture*

      1. consists of reusable, loosely coupled/independent objects responsible for different application functionalities
      2. Object-oriented concepts (abstraction, encapsulation, inheritance, etc)

   3. *Data-centred architecture*

      1. Components regularly access a common data repository and interact through the shared data store by reading or updating data
      2. Mainly consisting of a data store/repository and data accessors

   4. *Event-based architecture*

      1. Components communicate based on events
      2. typically involves publish/subscribe messaging

   5. *Service-Oriented Architecture* 

      1. Application functionalities are provided as loosely coupled services

      2. Use of standard interfaces (Web services) to invoke, publish,and discover services

      3. Message based interactions through interfaces

      4. Reuse of common services, automatic discovery, composition of

         services, interoperability to support different platforms

5. **Distributed Computing: System Architectures**:

   1. Vertical distribution: placing logically different layers/components on different machines
   2. Horizontal distribution: a single logical layer is distributed across multiple machines

6. **Client-Server Architecture**:

   1. The most widely used architecture
   2. Clients invoke individual servers
   3. Clients interact with the server processes to access resources
   4. Servers can be clients of other servers

7. **Thin Clients**:

   1. Tries to move complexity towards server/cloud
   2. Advantages: simple devices like a smart phone can be enhanced with a set of networked services and capabilities

8. **Peer to Peer Model**:

   1. applications consists of large numbers of peer processes running on separate machines

   2. resources such as processing power, data storage or files are shared with other peers

      ​

#  Web Services

1. **Information systems layers**:

   1. Resource Management (database) Layer
   2. Application Logic/Business Layer
   3. Presentation (user interface) Layer

2. **1-Tier**:

   {0}. *3 layers running on one machine*
   {0}. Dumb terminals and mainframes
   {0}. Layers tightly connected
   {0}. Difficulty with scalability and portability

3. **2-Tier**:

   {0}. Typically the <u>presentation layers runs on the client machine</u> and <u>the data layer on the server side</u>

4. **3-Tier**:

   {0}. Each layer almost independent and running on a separate tier
   {0}. Three layers sometimes called as <u>front-end, middleware and back-end</u>

5. **JavaServer Pages(JSP pages) and Servlets**:

   {0}. JSP is a <u>server-side technology</u> for creating dynamic web pages
   {0}. Servlets are Java programs to <u>extend server capabilities</u>
   {0}. **JSP is java in html** but **Serlet is html in Java**
   {0}. They can be used together to separte the presentation layer

6. **XML**:

   {0}. XML tags <u>not pre-defined</u> like HTML
   {0}. The goal of XML is to <u>provide a standardized way to specify data structures for data exchange and storage</u>
   {0}. XML Schemas has support for data types
   {0}. Unlike HTML, XML is not intended for browsers
   {0}. XML <u>can be automatically processed by other programs and machines</u>
   {0}. XML <u>can be used as the intermediate language for marshalling/serializing arguments when invoking services acrossthe Internet</u>

7. **Web Service**:

   {0}. A Web service is <u>a software system/application</u> designed to <u>support interoperable machine-to-machine interaction</u> <u>over a network</u>
   {0}. Hosting services on a remote machine
   {0}. <u>A standardized way of integrating web-based applications</u>
   {0}. The request and the reponse encoded <u>in a format easy for a program to decode (XML or JSON)</u>
   {0}. SOAP and RESTful web services

8. **A Web Service**:

   {0}.  has an **interface** describing a collection of operations

   {0}.  enables **access** to **business logic**, **data** and **processes** or other **services**

   {0}.  can be accessed by **humans**, other **applications** or other **WSs**

   {0}.  all **communications in XML** so not limited to any operating

      system or programming language (SOAP)

   {0}.  **easy and cheap** to develop with so many supporting tools

   {0}.  **Motivations**: Enterprise Application Integration (EAI), Supply chain and B2B



# SOAP

1. **What is SOAP**?

   - SOAP stands for <u>Simple Object Access Protocol</u>
   - SOAP is <u>an application communication protocol</u>
   - SOAP is <u>a format for sending and receiving messages</u>
   - SOAP is designed to <u>communicate via Internet</u>
   - SOAP is based on <u>XML</u>
   - SOAP is <u>platform</u> independent
   - SOAP is <u>language</u> independent
   - SOAP is <u>simple and extensible</u>
   - SOAP allows you to <u>get ground firewalls</u>

2. **The SOAP message path**:

   - A SOAP message can pass through **multiple hops** on the way from the initial sender to the ultimate receiver
   - The entities involved in transporting the message are called **SOAP nodes**
   - SOAP intermediaries forward the **message and may manipulate it**
   - Every SOAP node assumes acertain role which influences the message processing at the node.

3. SOAP message format:

   - **Envelope**
     - the **root** element of a SOAP message
     - SOAP message must always have an Envelope element associated with the "http://www.w3.org/2001/12/soap-envelope" **namespace**
   - **Header**
     - **optional** 
     - it contains application **specific information**: authentication, encryption, buffering/caching, etc
     - If Header is present, it must be **the first child element** of the Envelope element.
   - **Body**
     - **required**
     - it contains the **actual SOAP message** intended for the ultimate endpoint of the message
   - **Fault**
     - **optional**
     - used to hold error/status information for a SOAP message
     - If a Fault is present, it must be **a child element of the Body** element

4. **SOAP styles**: <u>document</u> and <u>RPC</u> styles

   - Document style:
     - the **body simply contains an XML document**
     - two interacting applications agree on the structure/format of documents exchanged between them
   - RPC style:
     - two sides a**greeing on the RPC method signature** instead of document structure
     - The request message **contains the actual call including the name of the procedure and input parameters**
     - The response message contains **the results and output parameters**
     - XML is used to serialize the parameters

5. **SOAP HTTP Binding**:

   - SOAP messages are <u>enclosed in the payload/body of an HTTP request or response</u>
   - A SOAP request could be an **HTTP POST** or and **HTTP GET** request
   - The HTTP POST request specifies at least two HTTP headers: **<u>Content-Type</u>** and **<u>Content-Length</u>**



# WSDL and UDDI

1. **WSDL**:

   - WSDL stands for <u>Web Services Description Language</u>
   - WSDL is <u>written in XM</u>L
   - WSDL is used to <u>describe web services</u>
   - WSDL is used to <u>locate Web services</u>

2. **WSDL Document Structure**:

   {0}.  **Types**:

      - defines the <u>data type that are used by the web services</u>

   {0}.  **Messages**:

      - defines the <u>**parts** of each message and the associated data **types**</u>

   {0}.  **PortType**:

      - describes the <u>**operations** that can be performed, and the **messages** that are involved
      - **operation** types:</u>

      | Type             | Definition                               |
      | ---------------- | ---------------------------------------- |
      | One-way          | The operation can receive a message but will not return a response |
      | Request-response | The operation can receive a request and will return a response |
      | Solicit-response | The opeartion can send a request and will wait for a response |
      | Notification     | The operation can send a message but will not wait for a response |

   {0}.  **Bindings**:

      - defines the <u>message formate and protocol details</u>

   {0}.  **Service**:

      - defines through <u>which port to access the web service</u>, <u>which binding to use</u>

3. **UDDI**:

   - A **directory service** where businesses can register andsearch for Web services.
   - Originally, conceived as an “Universal Business Registry”
   - UDDI aims to **find the service one actually wants among a potentially large collection of services and servers.**
   - The goal is that **the client does not necessarily need to know where the server resides or even which serverprovides the service** (pointers to WSDL).







# REST Architecture

1. **Architectural constraints**:

   - Client/Server
   - Stateless
   - Code-on-Demand
   - Uniform Interface
   - Layered System
   - Cacheable

2. **Client-Server**:

   - separating the **user interface** concerns from the **data storage** concerns
   - allows the components to evolve independently
   - improve the **portability** of the user interface across multiple platforms
   - improves **scalability** by simplifying the server components

3. **Stateless**:

   - each request from client to server must contain <u>**all of the information necessary to understand the request**</u>
   - it **cannot** take advantage of any stored context on the server
   - Improves **scalability** and **reliability**

4. **Cacheable**:

   - If a response is cacheable, then a client cache is given the right to **reuse that response data for later, equivalent requests**
   - Improves **network efficiency and performance**
   - decreases **reliability**

5. **Uniform Interface**:

   - all resources are accessed with a generic interface (e.g.,**HTTP GET, POST, PUT, DELETE**)
   - the overall system architecture is **simplified**
   - degrades **efficiency**, since information is transferred in a standardized form rather than one which is specific to an application's needs

6. **Layered System**:

   - improve system **scalability**

7. **Code-On-Demand**:

   - Optional
   - allows client functionality to be extended by downloading and executing code in the form of **applets or scripts**

8. **REST-Interface Constraints**:

   - identification of <u>resources</u>

     - REST is based on these notions which are <u>resource</u> and <u>resource identifier</u>

     | Method | Meaning                               | Idempotent |
     | ------ | ------------------------------------- | ---------- |
     | GET    | Retreive a copy of a Resource         | YES        |
     | DELETE | Remove a Resource                     | YES        |
     | POST   | Create or sometimes update            | NO         |
     | PUT    | Update a resource or sometimes create | YES        |
     | PATCH  | Update only part of a resource        | YES        |

     - <u>*Difference between PUT and POST*</u>
       - POST is not idempotent but PUT is
       - The <u>client</u> uses **PUT** when it’s <u>in charge of deciding which URI</u> the new resource should have
       - The client uses **POST** when <u>the server is in charge of deciding which URI</u> the new resource should have

   - manipulation of resources through <u>representations</u>

     - A representation of a resource is a <u>*document capturing current state of a resource*</u>
     - A resource can have different representations
     - Client can <u>specify which representation can accept</u> (e.g. in http accept header)
     - A resource representation <u>provides links for navigation and accessing further resources</u>

   - <u>self-descriptive messages</u>

     - REST constrains messages between components to be self-descriptive in order to support intermediate processing ofinteractions
     - <u>*each message contains all the information necessary tocomplete the task*</u>

   - <u>hypermedia</u> as the engine of application state(HATEOAS)

     - HyperMedia is a term used for hypertext which is not constrained to be text: <u>*it can include graphics, video and sound*</u>
     - Hypermedia links <u>*control the client choices that can lead to change of application state*</u> therefore it acts as an engine

9. **Mashups**:

   - A mashup, in web development, is a web page, or web application, that <u>uses content from more than one source</u> to <u>create a single new service</u> displayed <u>in a single graphical interface</u>

10. **Annotations**:

 - @Produces
   - specifies **the MIME media types** a resource can **produce** and **send back to the client**
 - @Consumes
   - specifies **the MIME media types** a resource can **consume** that **were sent by the client**





# Radio Communications and Cellular Networks

1. **Data Transmission**:

   - Analogue data over analogue signal
   - Analogue data over digital signal
   - Digital data over digital signal, aka baseband
   - Digital data over analogue signal, aka broadband

2. **Electromagnetic radiations**:

   - A form of energy emitted
   - traveling in a wave-like pattern
   - have import properties:
     - Frequency: cycles per second (Hz)
     - Wavelength: distance between peaks (m)
     - Energy: the amount of energy found in the photons (electron volt eV)
   - Electromagnetic Spectrum: a rang of all possible frequencies of Electromagnetic radiation

3. **Propagation Modes**:

   - <u>Ground wave propagation</u>: signals below 2 MHz following the contour of the earth (e.g. AM radio communication)
   - <u>Sky wave propagation</u>: a signal from an earth-based antenna is reflected from the ionosphere, suitable for signals 3-30 MHz (e.g. amateur radio, international broadcasts)
   - <u>Line-of-Sight propagation</u>: signals above 30 MHz

4. **Propagation Characteristics**:

   - Radio waves can be **reflected**, **refracted**, **diffracted** or **absorbed**

   - **<u>Reflection</u>**: radio waves may be reflected from various substances or

     objects

   - <u>**Refraction**</u>: when radio waves move from one medium into another, theirspeed change and gradually bend

   - **<u>Diffraction</u>**: radio waves have a tendency to bend around obstacles andsharp edges

5. **Signal Impairmaent Types**:

   -   <u>Attenuation</u>
     - The strength of a signal **falls off** travelling through a medium and with distance
     - Use of **amplifiers** or **repeaters** to improve signal strength
     - With **higher frequencies**, **attenuation** is **greater**
   -   <u>Delay distortion</u>
     - Signal components are received with **varying delays**
   -   <u>Noise</u>
     - the received signal consisting of the transmitted signal **plus additional unwanted signals** that are inserted somewhere between transmission and reception

6. **Cellular Mobile Telephony**:

   - In cellular systems, the geographical coverage area is usually **divided into cells** (and then into clusters)
   - Each cell is usually represented as a **hexagon**
   - Cell **size** depends on **user density** and **transmission power**
   - Each cell is controlled by a **base station (BS)** that **supports the services of** **mobile stations (MSs)**

7. **Handover/Handoff**:

   - Handoff/handover when **the mobile user moves across cells**
   - Needs **tracking the location of the caller** to direct an incoming call to the right cell
   - When MS moves and **gets close to the border** of the existing cell, **BS informs MSC that a handover is required**
   - **MSC asks the neighbouring BS if they detect that mobile’s signal**
   - If so then **MSC coordinates handoff** between original BS and the new BS

8. <u>Frequency-Division Multiple Access</u>: 

   - Involves the division of the frequency band into sub-band channels
   - Each channel can be assigned to only one user at a time
   - Each call is carried on a separate frequency sub-band channel
   - Guard bands between sub-channels to avoid interference
   - Uplink and downlink with different frequency bands
   - **Used in 1G**

9. <u>Time-Division Multiple Access</u>:

   - Divides the channel into time slots
   - Each timeslot carries the data of a call
   - Requires coordination between BSs and time synchronization
   - **Used in 2G** 

10. <u>Code-Division Multiple Access</u>:

  - The entire channel/bandwidth is used simultaneously (no frequencyor time division) without any interference
  - More efficient use of the limited frequency spectrum
  - Each call in the spectrum is differentiated from other calls by assigning a unique code to each call's signal
  - **Mainly in 3G**

11. **<u>*Spread Spectrum Types*</u>**:

    - Direct-sequence spread spectrum (**DSSS**):
      - Data is divided into **chunks** that **are sent over few fixed, broad frequency channels**
      - **CDMA** is a Direct Sequence Spread Spectrum system
    - Frequency-hopping spread spectrum (**FSSS**):
      - The frequency spectrum is divided into narrow channels
      - Data packets are split up and hop around these channels in a pseudo-random sequence known only to the transmitter and receiver

12. **1G: first generation**

    - The radio signals are **analogue**, carrying **voice** only
    - Based on frequency division multiple access (**FDMA**)

13. **2G: second generation**

    - Radio signals are **digital** and support for digital data services
    - Allowing better **security** of data and **digital encryption**, **better sound quality** (resistance to noise) and **efficient error correction** on bits
    - **First** based on **TDMA**, **Later** **CDMA** used as a solution

14. **3G: third generation**

    - Increased **capacity** to support greater numbers of voice and datacustomers, especially in urban areas
    - **Higher data rates at lower cost**
    - **Fast and efficient transmission** of voice, data & video

15. **4G: fourth generation**

    - **More improved data rates and performance**
    - **Faster download speeds** and a quicker overall mobile internet experience
    - Major standard: **LTE** (Long Term Evolution) and **WiMAX**







# Wireless LAN and IEEE 802.11

1. Radio Frequency Ranges:
   - The frequency range directly **affects the data rates to be transmitted**
   - **The higher the frequency range** (called bandwidth), the **greater the capacity of the wireless circuit**, allowing the signal to carry moredata and faster (but also depends on the data transmission method)
   - **Higher frequencies suffer attenuation more quickly** than lowerfrequencies
2. Wireless Distribution System (WDS)
   - **Wireless Bridging** in which the APs <u>communicate with each other and with other the wireless clients</u> (as routers)
   - Wireless Point-to-Point Bridge or Wireless Point to Multi-Point Bridge
   - **Wireless Repeating** in which access points <u>communicate only with each other</u> (as repeaters), extending the wireless reach of an existing AP





# JPQL and NamedQueries

1. Entity Classes:

   - Entity classes are <u>used to create persistent entity objects</u>
   - Entity classes are <u>POJO (Plain Old Java Object) classes</u>
   - Entity classes have the **@Entity** annotation
   - Entity classes import **javax. persistence.Entity**
   - Entity classes include <u>getter and setter methods</u>
   - Entity classes <u>use annotations above each of the variables</u> for keys, column names, not null attributes, and relationships

2. Two options of queries:

   - **Static queries** (define the query in the <u>entity class</u>)
     - createNamedQuery
   - **Dynamic queries** (define the query in <u>REST façade class</u>)
     - createQuery

3. JOIN:

   - **Implicit JOIN**: 

     ```
     SELECT s FROM Student s WHERE s.courseid.coursename = :coursename
     ```

   - **Explicit JOIN**: It requires writing a query that explicitly use the ‘JOIN’ in the query







# Enabling Wireless Technologies & Networks

1. WiMax:

   - IEEE 802.16 is a family of standards for WirelessMAN (Metropolitan Area Networks) for use in **large**, **city-sized** wireless networks
   - **WiMAX** (Worldwide Interoperability for Microwave Access) is the **commercial name for IEEE 802.16 standards**
   - WiMAX also a competing technology **used in 4G**

2. Fixed and Mobile WiMAX:

   - WiMAX **Base Station** (BS): connected to a <u>public network</u>
   - **Subscriber Station** (SS): usually <u>serves a building</u>
   - **To cover the "last mile" area**: providing high-speed Internet access to the areas which normal wired technologies do not cover
   - Later mobility support was considered in Mobile WiMAX, **a technology for wide area wireless networks**

3. LTE and WiMAX:

   - WiMAX and LTE (Long-Term Evolution) are the **two key 4G mobile broadband technologies**
   - Both **based on OFDM and MIMO** but they **use different frequency channel bandwidth** and also **different modulation methods** in uplinkand downlink connections


- **WiMAX** was introduced to <u>deal with the last mile issue</u> and **LTE** <u>originally created for cellular networks</u>
   - LTE  better integrated with other cellular technologies, making for smoother transitions between 3G and 4G

4. Bluetooth (802.15.1):

   - A **short-range wireless communication technology and standard**
   - <u>Short range, low power and efficient</u>
   - Operates in the <u>2.4 GHz ISM unlicensed band</u>
   - <u>No line of sight issues</u> 
   - Uses <u>FHSS</u> frequency hopping Spread Spectrum technique

5. Piconets:

   - Bluetooth enables wireless communicationbetween nodes
   - Nodes <u>dynamically paired with no prior knowledge</u>
   - **Master**: the initiating node and controlling the use of the channel
   - **Slave**: the other connecting node
   - <u>Nodes in more than one piconet act as a bridge</u>
   - A device can act <u>as both master and slave</u>

6. ZigBee (802.15.4): 

   - For low-rate WPANs (Wireless Personal Area Networks)
   - Operates in the <u>ISM unlicensed band, in the 868 MHz, 915 (900-928) MHz</u>
   - ZigBee uses Direct Sequence Spread Spectrum (**DSSS**)
   - <u>*Benefits*</u>:
     - Easy to setup and maintain (mesh, self-organizing)
     - Reliability (self-healing)
     - Ability to scale to thousands of devices (nodes)
     - Long battery life
     - Low cost

7. RFID:

   - RFID (Radio Frequency Identification) is **an electronic tagging/identification technology** which **facilitates automatic identification**
   - Without any contact
   - Without the line of sight
   - By exchange of electromagnetic signals between **readers** and **tags**

8. Types of Transponders/Tags:

   - *Passive*:
     - <u>No internal power source</u>
     - They draw their power <u>from the electromagnetic field generated by the RFID reader</u>
     - When radio waves from the reader are encountered by a passive RFIDtag, the coiled antenna <u>forms a very small magnetic field</u>
     - The tag draws power from this field, energising the circuits in the tag
     - The tag then <u>sends the information encoded in the tag's memory</u> to the reader
   - *Semi-passive*:
     - Semi-Passive Transponders <u>have their own power source</u> (a smallbattery) that **powers the microchip only**
     - The battery is needed <u>only for the tag’s operation</u> (not for transmitting signal back to the reader)
     - Like passive tags, they **have no transmitter**
     - They can act faster than the passive tags
     - The read range for a semi-active tag can be up to ~6-30 meters
   - *Active*:
     - They **have transmitters and internal power** (on-board battery) to power up the microchip and transmit signals to a reader
     - The read **range is much greater** than Passive ones, up to 100 meters
     - Very expensive compared to passive tags and bigger in size
     - Operates in high frequency range: e.g. 455 MHz, 2.45 GHz or 5.8GHz
     - <u>Used for tracking expensive assets over a large area or vehicles</u>(military, shipping or mining industries)

9. Reading and Writing to RFID Tags:

   - Read only (RO) tags:
     - The **manufacturers** of tags **burn permanently data for the tag onto the microchip**
     - It is also referred to as factory programmed tag.
   - Write-once, read many (WORM):
     - This kind of tags **enables the users to modify or update the tag’s information**. Security-wise these are better than RW tag.
     - These are also available at a lower cost.
   - Read write (RW):
     - Here the **reader can be used to modify data in the tags**
     - This kind of tags is also **known as field programmable or re-programmable**

10. RFID Classes:

  | EPC Class Type  | Features                                 | Tag Type              |
  | --------------- | ---------------------------------------- | --------------------- |
  | Class 0         | Read Only                                | Passive (64 bit only) |
  | Class 1         | Write Once, Read Many (WORM)             | Passive (96 bit min.) |
  | Class 2 (Gen 2) | Read/Write                               | Passive (96 bit min.) |
  | Class 3         | Read/Write with battery power to enhance range | Semi-Active           |
  | Class 4         | Read/Write active transmitter            | Active                |

11. NFC (Near Field Communication):

    - A <u>very shor range wireless radio communication technology</u>
    - Based on RFID standards

12. Types of NFC Devices

    - Passive Mode (between a NFC device and tag):
      - A passive device (such as an NFC tag) **stores information that other NFC devices can read**
      - A passive device **uses energy from the reader** to send data
      - E.g. a sign on a wall
    - Active Mode (between two NFC devices):
      - **Both devices can read and send information** (peerto peer)
      - **Both devices have their own source power**
      - E.g. smartphones

13. Overview:

    ![overviewPix](https://ws2.sinaimg.cn/large/006tNbRwgy1fg4gfc5cr7j30xc0eudi3.jpg)





# Android

1. Native Apps:

   - **Written in a native language** like Android or Swift, socompiled into machine code
   - Better performance
   - Can **be directly installed** on the mobile device
   - Can **be distributed through native app stores** (Apple Store orGoogle Play)
   - Provide **access to all the standard tools and features** and are compatible with the device’s hardware and native features,such as sensors like accelerometer, camera or hand gestures
   - They can be used **offline**
   - **But specific to certain mobile platform and not cross-platform**

2. Web Apps:

   - Usually in **HTML5 and CSS and JavaScript**
   - **No need to download** and install the app


- Run in the web **browser** of the device
   - **Flexibility** to run on different platforms
   - **Easier to modify and update** (cost-efficient development andmaintenance)
   - **Limited access to device-specific features, sensors and functionalities**, tries to mimic them

3. Hybrid Apps:

   - Similar to web apps **use HTML, CSS, and JavaScript** 
   - Instead of running on a web browser, they **run on a WebView hosted inside a native container** 
     - Webview: a browser like view to load and display web contents within a native app
   - Hybrid apps **can access device features and capabilities like sensors, the accelerometer or camera**
   - **Platform independent** (unlike native apps)

4. List view:

   - A view group that **displays a list of scrollable items**
   - The list items are automatically inserted to the list using an **Adapter** that pulls content from a source such as an array ordatabase query

5. Navigation Drawer Layout:

   - A navigation drawer is a panel that displays the app’s main navigation options on the left edge of the screen
   - Enables navigation between fragments
   - It is hidden most of the time and can be shown by swiping the screen from left edge to right or tapping the app icon on the action bar.

6. Producing an Android App

   ![preduceAndroidApp](/Users/YuanZhan/Desktop/preduceAndroidApp.png)

7. <u>***build.gradle Files***</u>:

   - Android build gradle **provides a custom build tool to manage and configure building android apk files** 
   - It facilitates **finding, importing, downloading and adding local and remote dependencies**
   - There are two build gradle files in the current version of Android
     - <u>build.gradle (Project: APPLICATION_NAME)</u>
     - <u>build.gradle (Module: app)</u>
   - The scope of gradle **Project** is for **the whole project**
   - The scope of gradle **Module** is just for **that module**
     -  Some projects can have multiple modules (Module 1, 2, ...)
   - Gradle files enable you to easily import and use remote repositories using *jcenter()* and maven
   - JCenter is **a Java repository in bintray**
   - A repository refers to **location/directory where all the libraries and jar files(or any required files) are stored and used by Maven**

8. MainActivity.java

   - MainActivity.java defines <u>how the application will behave and interact with the user</u>
   - When you build and run your application, MainActivity class <u>starts the activity and loads the layout file that passed through setContentView()</u>

9. View:

   - It is <u>the basic building block for user interface components</u>
   - It is <u>responsible for drawing and event handling</u>
   - It is the base class for widgets (buttons, text fields, etc.)
   - ViewGroup is the base class for layouts which can contain otherviews

10. AndroidManifest.xml:

  - All Android applications have an AndroidManifest.xml file under apps/manifests
  - It **includes the important information about the app**:
    - The name the Java package
    - Description of the components of the application such as the activities, services
  - For declaring the required **permissions** like the access to the internet

11. Model-View_Controller Design Pattern:

    - A software design pattern that focuses on the separation ofconcerns (main functionalities) in an application to promote reuse 
      - Model: Defines **the data and state of the program**
      - View: Defines **how the user sees and interacts with the program**
      - Controller: involves **business logic** to interface the View to the Model and can modify the properties of each
    - MVC design pattern can be viewed as guiding principles to goodprogram design
    - **<u>*It is slightly different in Android*</u>**

12. **MVC in Android**:

    - Model
      - It is responsible for the data that is accessed and stored by the application
      - In Android, **it can be a class that interacts with database (local or remote)or stores program state, or a mix both**
    - View
      - The user interface presented to the user
      - It handles the way data is presented and the manner in which users can interact with our apps
      - In Android, **Views and ViewGroups** (layouts) as xml files
    - Controller
      - It is like a connector between the Model and View
      - It can make changes to the model and also reflect changes in the view
      - In android, **Activities and Fragments**

13. Passing Data:

    - Intent:

      - An Intent is a messaging object you can <u>use to request an action from another app component</u>

      - Intents <u>facilitate communication between **components**</u>

      - You can also use the intent to **<u>start a new instance an activity</u>** (a second activity), by passing an Intent to startActivity()

        ```
        Intent intent = new Intent(this, AnotherActivity.class);
        startActivity(intent);
        ```

      - The intent can also be used:  

        - <u>To start a service</u>
          - A Service is a component that performs operations in the background withouta user interface (e.g. downloading a file)
        - <u>To start a broadcast</u> (a message that any app can receive)

      - Pass Primitive Data:

        ```
        intent.putExtra(String name, String value);
        intent.putExtra(String name, double value);
        intent.putExtra(String name, int[] value);
        ```

      - Get Data from Intent

        ```
        Intent intent= getIntent();
        //using the message name to get its value
        String msg = intent.getStringExtra(“message”);
        ```

    - Bundle:

      - Bundle is a “**<u>mapping from String keys to various Parcelable values</u>**”

      - Bundle enables **passing data between activities and fragments**:

        ```
        Bundle bundle=new bundle(); // in the sender activity bundle.putString(name, value); // in the sender activity intent.putExtra(bundleName, bundle); // in the sender activity

        // in the receiver activity
        Bundle receivedBundle= getIntent(). getBundleExtra(bundleName);

        // other way
        intent.putExtras(bundle); // in the sender activity
        Bundle receivedBundle=getIntent().getExtras(); // in the receiver activity

        // pass Parcelable objects:
        bundle.putParcelable(“student", student);
        intent.putExtras(bundle);
        // In the other activity or fragment
        Bundle bundle = getIntent().getExtras(); bundle.getParcelable (“student");
        ```


14. **<u>*Steps to create Pacelable Class*</u>**:

    - Create a class that **implements Parcelable**
    - Implement all **get and set** methods for its attributes
    - Implement **writeToParcel** to write values to parcel in a specific order
    - Implement the **constructor** for reading in values in the sameorder
    - Include a **static field called CREATOR** that implements theParcelable.Creator interface

15. SharedPreferences

   - SharedPreferences enables to <u>save and retrieve persistent key-value pairs of primitive data types between multiple fragments and activities</u> 

   - A SharedPreferences object <u>points to a file containing key-value pairs</u>

   - To get a SharedPreferences object, we call `getSharedPreferences(String file, int operatingMode)`

     ```
     SharedPreferences spMyUnits =  getActivity().getSharedPreferences("myUnits", Context.MODE_PRIVATE);
     ```

   - To write to a shared preferences file, you need to create aSharedPreferences.Editor by calling `edit()`

     ```
     SharedPreferences.Editor eMyUnits = spMyUnits.edit();

     // You will pass the keys and values to the Editor with available methods such as putLong(), putInt(), putString():
     eMyUnits.putString("myUnits", jaMyUnits.toString());

     // You will finally call Apply or commit to save changes (commit returns a Boolean value true if successful)
     eMyUnits.apply();

     // To read values, use SharedPreferences methods like getString() and pass the key
     String sMyUnits = spMyUnits.getString("myUnits", null);
     ```

16. Fragments:

    - A Fragment **represents a behavior or a portion of user interface in an Activity**
    - A fragments is **<u>like sub-activity</u>** that lives inside an activity
    - Fragments can <u>**be used to provide reuse and modularity**</u>
    - Fragments can be used **<u>for building dynamic and multi-pane user interfaces**</u>

17. Single Thread Model:

    - When an Android application is launched, <u>the system creates a"main." thread, aka the UI thread</u>
    - The UI Thread is **the single thread of execution** for your application
    - It is the **thread** in which <u>the application interacts with components from the Android UI toolkit</u>
    - **<u>*Two rules to Android's single thread model*</u>**:
      - <u>Do not access the Android UI toolkit from outside the UI thread</u>  
      - <u>Do not block the UI thread</u>

18. AsyncTask:

    - AsyncTask **allows to perform background operations and publish results on the UI thread** without having to manipulate threads and/or handlers

    - AsyncTask must be subclassed to be used:

      ```
      private class Factorial extends AsyncTask<String, Void, String> {
      ```

    - The subclass will override at least one method (`doInBackground(Params...)`)

      ```
      protected String doInBackground(String... params) {
      ```

    - Most often will override a second method (`onPostExecute(Result)`)

      ```
      protected void onPostExecute(String result) {
      ```

    - Other methods: `onPreExecute()` and `onProgressUpdate(Progress...)`

19. Types:

    -   The three types used by an asynchronous task are the following:  `AsyncTask<Params, Progress, Result>`
      - **Params**: the type of the parameters sent to the task (`doInBackground()`)  It can be an array of objects
      - **Progress**: the type of the progress units published during the backgroundcomputation (optional)
      - **Result**: the type of the result of the background computation(`onPostExecute()`)

20. HttpURLConnection:

    - Android app can <u>have network functionality</u>

    - To <u>use http to send and receive data</u>, HttpURLConnection can be used

    - HttpURLConnection enables your Android app to <u>interact with REST web services as well</u>

    - You can use http methods like <u>GET, POST, PUT or DELETE</u> in HttpURLConnection to access and modify data by invoking REST methods

    - Before using HttpURLConnection, you make sure that the manifest file includes the internet permissions

      ```
      <uses-permission android:name="android.permission.INTERNET" />
      ```

21. Code:

    ```
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    url = new URL("http://ipaddress:8080/FriendsDB/webresources/friend.friends");
    conn.setRequestMethod("GET");
    conn.setRequestProperty("Content-Type", "application/json"); conn.setRequestProperty("Accept", "application/json");
    Scanner inStream = new Scanner(conn.getInputStream());
    while (inStream.hasNextLine()) {
    textResult += inStream.nextLine(); 
    }
    ```













# Wireless Sensor Networks (WSN)

1. **Wireless Sensor Networks** (WSNs)

   - It is <u>composed of a large number of sensor nodes</u>, which are <u>densely deployed in an area</u> to allow <u>monitoring of the physical world</u>.
   - Sensor networks are <u>massive numbers of small, inexpensive, self-powered devices</u> *pervasive* throughout electrical and mechanical systems and *ubiquitous* throughout the environment that <u>monitor and control most aspects of our physical world</u>.

2. **Sensor Nodes**

   - Nodes communicate the collected information through wireless links (radio) to usually a sink/base station
   - Each sensor has the ability to collect and also route data
   - Usually sensor management protocols determine which nodes sense and which ones to route data to ensure energy efficiency
   - Nodes have <u>minimal CPU, memory and extremely low power</u>
   - Nodes can be **stationary** or **moving**
   - Nodes can be aware of their <u>location</u>
   - Nodes can be <u>homogeneous</u> or <u>not</u>

3. Sensor Components:

   - A sensing unit: 
     - produces a measurable response to a change in a physical condition like temperature
   - A communication unit (Transceiver):
     - Used to send and receive short range radio signals
   - Additional components:
     - a global positioning system (GPS) in location aware sensors
     - A motor to move mobile sensor nodes
     - SD cards for storage
   - A power unit: supply energy
     - Battery-powered
     - Energy-Harvesting

4. State Transition:

   - The transition time for entering and exiting sleep modes differs
   - Nodes in deeper sleep consume less energy but it requires higher energy to wake them up
   - The total energy cost = the state energy consumption + the state transition energy consumption

5. Sink:

   - Data collected by sensors usualy forwarded to a sink
   - A sink has high resources (memory, CPU, storage, power source)
   - A sink can use data locally, performing simple data processing OR it can serve as a gateway for connecting to the Internet (remote sensing)
   - It can send queries or commands to nodes while sensors collaborate to accomplish the sensing task and send the sensed data to the sink

6. Multi-hop sensor networks:

   - Flat sensor network
     - All sensor node have the same role and act as **peers**
     - In such network, the sink usually **sends a query to all the nodes **and **only the nodes that have the data satisfying the query will respond**
     - The sensor node can also act as a **router** and transfer data to a sink through multi-hop routing, using their peers to relay the data
   - Hierarchical / clustered architecture
     - Sensor nodes are grouped into clusters
     - Each cluster has <u>a cluster head (CH)</u>
     - <u>Sensor nodes in each cluster send data to its CH</u>
     - CH performs **simple processing** and **sends processed data** to the sink
     - <u>Reduces **energy consumption** for communication</u>
     - Improves <u>scalability</u> for larger networks and <u>balances traffic load</u>

7. Query Sensor nodes:

   - Query Request: includes a query from the BS to the sensor nodes in a region of interest
   - Query Response: carries a query answer back to the BS

8. Query Categories:

   - Historical query: used for analysis of historical data stored at a remote BS or any specific node
   - One-Time/snapshot Query: provides an instantaneous view of the network
   - Persistent/continuous Query: used to monitor a network for a continuous period of time
   - Event-driven Query: data is transmitted when an event occurs

   **<u>*OR*</u>**

   - Spatial Query: queries data according to a given space of interest

     ```
     SELECT attr_val FROM sensor WHERE loc=[ −200,200,400,600]
     ```

   - Temporal Query: queries data during a specified time or period of time

     ```
     SELECT attr_val FROM sensor WHERE time=6:50am – 2:30 am
     ```

   - Spatio-Temporal Query: combines both spatial and temporal queries

9. Flooding and Gossiping:

   - **<u>Flooding</u>** is the simplest routing technique
     - The node <u>**broadcasts the data and other nodes retransmit it to all its neighbours**</u> till it arrives at the sink
     - Flooding causes **implosion** and overlap because nodes and the network will <u>receive multiple copies of the same data messages</u>
     - The network also wastes energy and bandwidth
   - **<u>Gossiping</u>**: the receiving nodes **<u>broadcast data to only randomly selected neighbours</u>**
     - It addresses the implosion
     - But <u>still energy wastage and overlapping</u> can occur as the network might have the same copies of data

10. **Routing Protocols Classification**:

    - Hierarchical (clustered) routing 
    - Attribute-based routing
    - Location-based routing
    - Data-centric routing
    - Directed Diffusion
    - Energy-based routing
    - Quality of Service (QoS) routing

11. Data-centric Routing:

    - **Intermediate sensors** perform **<u>data aggregation</u>** to <u>prevent data redundancy and also reduce energy consumption</u>
    - In-network Processing:
      - Some data processing taking place within the network on sensors
      - **Based on the fact that processing is less energy consuming than communication**
      - Benefits:
        - It prevents the bottleneck problem
        - Solves the overlap problem and implosion (i.e. caused byduplicates)
        - It reduces energy consumption by minimizing the amount of data that is transmitted, and extends the network lifetime

12. Quality of Service (QoS) Rounting:

    - QoS routing aims to <u>balance data quality and energy consumption to achieve route optimisation</u>
    - Focusing on: energy, success delivery ratio, delay, bandwidth





# Ubiquitous Computing and Context-Awareness

1. Ubiquitous/Pervasive Computing:
   - 'invisible’ **sensing and processing devices** are so **embedded in our environment** so natural, so friendly **we use them without even noticing**
2. HCI (Human-Computer Interaction):
   - a multidisciplinary design science, deals with **the interactions between humans and computers**, where certain tasks are performed
   - happens through an **interface**
   - In HCI, the aim is to improve the **usability** of computer interfaces
3. Context-Awareness:
   - Context-awareness is considered a key component of ubiquitous computing systems
   - It enables an application to be:  
     - <u>adaptive to dynamic changes</u>  
     - <u>user-centric and personalised</u>  
     - <u>intelligent and proactive</u>
     - <u>cost-efficient</u>
4. Context:
   - Context is **any useful information related** to a network, application, environment, process, user or device
   - It is **any information** that can be used to **characterize the situation of an entity**
   - Contextual information can be <u>sensed, derived, reasoned, computed, calculated or explicitly entered</u> by users
5. Context-Aware Computing:
   - A context-aware system is **aware** of the current context (state, surroundings, location, etc) and **uses this information** to **adapt its behaviour or operations** accordingly
   - It is 	the ability of applications to sense and react to contextual information about environment, location, time, or user
6. Situation: High level context
   - Situations are **inferred** through using reasoning/inference methods
   - **Aggregation** (fusion) of data from multiple sensors and sources to <u>provide a wider and more general view of surrounding environment</u>
   - Context & Situations:
     - For a health monitoring application:
       - Context: heart rate, blood pressure, body temperature
       - Situations: healthy, hypertension, hypotension, heat stroke
     - For a fire monitoring application:
       - Context: wind speed, temperature, light
       - Situations: fire, fire-threat, safe
     - For monitoring offices:
       - Context: noise, light, motion
       - Situations: meeting, presentation, vacant
7. Mobile Crowdsensing:
   - The term “crowdsensing” refers to **using the power of the crowd** to **collect information** regarding phenomena of interest **with the use of available sensors in the mobile and wearable devices**
   - MCS applications remotely collect data about the environmentand physical world
   - It relies on <u>mobile and sensing devices</u>, and <u>cloud computing</u>
   - The key contextual information: location and accelerometer
   - **Privacy** is a main issue
8. Participatory and Opportunistic Sensing
   - **Participatory sensing**
     - Users are directly involved in the data collection process
   - **Opportunistic sensing**
     - Users are not directly involved in the data collection process (minimal involvement)
     - Sensing tasks happen in the background
     - Mobile devices decide when and how they should participatein a sensing task
9. Types of Things in IoT:
   - **Tagging things** that have <u>identity and can be identified by other things</u>
   - **Sensing things** that <u>use services and may have sensing capabilities</u>
   - **Computing things** that can <u>initiate communication, do reasoning and make decisions</u>
   - **Things that can control, coordinate, create, manage and remove otherthings**
   - **Internet of Everything** (IoE), Cisco
     - Consists of: People, Data, Process, Things





# Location-Awareness & GPS Technology

1. Location:
   - A **relative location**, meaning <u>the location of one object relative to another</u>
   - An **absolute location** based on <u>the exact location of an object using a specific pairing of latitude and longitude</u>
2. Location Aware Computing:
   - Used to determine the geographical location of objects.
3. Three **principal techniques for automatic location sensing**:
   - Scene analysis
   - Proximity
   - Lateration and angulation
4. Trilateration and Triangulation:
   - Lateration (**Trilateration**): computes the position of an object <u>by measuring its **distance** from multiple reference positions</u>
   - **Triangulation**: uses <u>both **distance** and the **angles** (the geometric properties of triangles) for determining the position of an object</u>
5. GPS Architecture:
   - GPS satellites
   - GPS receivers
   - Ground stations
6. To determine the location of an object:
   - **Locate** four or more of the satellites
   - **Calculate the distance to each** by <u>measuring the transit time of the signal between the satellite and the receiver and multiplying by the speed of light</u>
   - **Perform trilateration** using this information to determine the location
   - Also calculate and consider the receiver’s **clock bias** (time synchronization)
7. Location Aware Computing Challenges:
   - Absolute versus relative location
   - Accuracy (how close are readings to real values)
   - Precision (how consistent are readings)
   - Indoor positioning: Identifying the floor level
   - Energy management
   - Privacy and security issues
   - Integration of multiple location sensing technologies





# Cloud Computing

1. Cloud computing:
   - Cloud computing is **the on-demand delivery** of compute power, database storage, applications, and other IT resources **through a cloud services platform** via the **internet** with pay-as-you-go **pricing**
2. Cloud Layers:
   - IaaS:
     - IaaS provides the **infrastructure** including networking features, computers (virtual or on dedicated hardware), and storage
     - IaaS provides **the highest level of flexibility and management** controlover IT resources
       - It allows the users to control the underlying cloud infrastructure
     - **Suitable for new business**, no need to buy hardware, servers, storage
     - **Suitable also for growing businesses**
     - Sometimes there is overlapping between IaaS and PaaS
   - PaaS:
     - Platform as a Service
     - PaaS provides **the computing platform** (hardware and operating systems) for deploying and managing applications
     - Suitable for easier and faster for hosting web applications
     - Suitable for **collaborative development**
     - Suitable for **testing and deployment**
   - SaaS:
     - Software as a Service
     - Applications run on the cloud and users can connect from any computer to access them using a web browser
     - No need to buy, install, update, and maintain
     - It is beneficial:
       - For expensive commercial software and licenses
       - Supports both web and mobile access  
       - For emails
3. Different Models of Cloud:
   - **Public cloud**
     - All the hardware, software, or supporting infrastructure, are owned and managed by providers and are accessed over the Internet
   - **Private cloud**
     - It is operated on a private network by anorganization (not shared with any other organizations), and hosted on-premiseinternally or externally by a third party
   - **Hybrid cloud**
     - A combination of public and private cloudnetworks
4. Fog Computing:
   - Computing at the ‘**edge**’ of the network
   - A fog node (edge) is **any device** <u>with computing, storage, and network connectivity</u> such as routers, switches, gateways,embedded servers and video surveillance cameras in cars, factoryfloors, railway tracks etc
5. When to do fog computing:
   - When **data can be processed at the network edge**
   - When **a large number of smart things in a large area** are producing data
   - When there is **a need for analysing data in milliseconds**
6. Benefits of Fog Computing:
   - **Security**
     - Sensitive data can be analysed in the fog rather than sending it to the cloud
   - **Efficiency**
     - Reducing costs of network bandwidth and data transfer by aggregating and processing reginal data locally and sending summary of data to the cloud forfurther analysis (computationally intensive)
   - **Internet unavailability**
     - Data can be buffered at the fog nodes and later uploaded to the cloud
   - **Addressing big data problems**
     - Reducing response time by performing less complex analysis of data on the fog and providing faster response
     - Sending only summary of big data to the cloud